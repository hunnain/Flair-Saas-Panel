const UserModel = require('../models/shopAdminSignup');
const ShopBranchesModel = require("../models/shopLocation");
const ShopCustomersModel = require("../models/shopCustomersSingup");
const ShopBarbersModel = require("../models/shopBarberSignup");
const BarberChoosenServicesModel = require("../models/BarberChoosenServices");
const ShopServicesModel = require("../models/shopServices");
const ShopServicesCategoryModel = require('../models/shopServicesCatgories');
const BookingModel = require("../models/createBooking");
const BlockTime = require("../models/barberBlockTime");
const sgMail = require('@sendgrid/mail');
sgMail.setApiKey(process.env.SENDGRID_API_KEY);
const bcrypt    = require('bcrypt');
const stripe    = require("stripe")(process.env.STRIPE_SECRET_KEY)
const jwt 	    = require('jsonwebtoken');
const accountSid = process.env.TWILIO_ACCOUNT_SID;
const authToken = process.env.TWILIO_AUTH_TOKEN;
const client = require('twilio')(accountSid, authToken);
const mongoose  = require('mongoose');
const moment = require('moment-timezone');
const validateBarberWorkingHours = require('./validations/shopBarberworkinTimeOnbranchValidation');
const {chargeCustomerCardBarber, capturePaymentStripePOS} = require('./validations/payments');

// Auto Genrate String Numbers Function
function makeid(length) {
    let result = '';
    const characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
    const charactersLength = characters.length;
    let counter = 0;
    while (counter < length) {
      result += characters.charAt(Math.floor(Math.random() * charactersLength));
      counter += 1;
    }
    return result;
}

function generateAccessToken(userObj) {
    const TOKEN_SECRET = process.env.TOKEN_SECRET
	return jwt.sign(userObj, TOKEN_SECRET, { expiresIn: '15d' });
}

// Signup for the Barber of shop
exports.signupBarberOfShop = async function (req, res) {
    try {
    if (!req.body.email || !req.body.mobile || !req.body.firstName || !req.body.lastName || !req.body.role) return res.status(400).send({success: false, message:"Invalid Request"});
    const barberEmailChecking = await ShopBarbersModel.findOne({
		email: req.body.email,
        shopAdminAccountId: req.user._id
	})
    if (barberEmailChecking) return res.status(400).send({success: false, message:"Email already exist"});

    const barberMobileChecking = await ShopBarbersModel.findOne({
		mobile: req.body.mobile,
        shopAdminAccountId: req.user._id
	})
    if (barberMobileChecking) return res.status(400).send({success: false, message:"Mobile already exist"});  

    // Checking Shop ID
    const adminuser = await UserModel.findOne({
        _id: req.user._id
	})
    if (!adminuser) return res.status(400).send({success: false, message:"Shop Not Found"});

    var shopBarbersModel = new ShopBarbersModel();
    shopBarbersModel.shopAdminAccountId =  req.user._id
    shopBarbersModel.email =  req.body.email
    shopBarbersModel.isMobileVerified =  false
    shopBarbersModel.isEmailVerified =  false
    shopBarbersModel.isPasswordChange =  false
    shopBarbersModel.mobile =  req.body.mobile
    shopBarbersModel.firstName =  req.body.firstName
    shopBarbersModel.lastName =  req.body.lastName
    shopBarbersModel.role =  req.body.role
    if(req.body.workingLocation){
        shopBarbersModel.workingLocation.push(req.body.workingLocation)
    }
    if(req.body.isOnCommission){
    shopBarbersModel.isOnCommission =  req.body.isOnCommission
    }
    if(req.body.isOnRent){
    shopBarbersModel.isOnRent =  req.body.isOnRent
    }
    if(req.body.commissionPayoutFrequency){
    shopBarbersModel.commissionPayoutFrequency =  req.body.commissionPayoutFrequency
    }
    if(req.body.rentCollectionFrequency){
    shopBarbersModel.rentCollectionFrequency =  req.body.rentCollectionFrequency
    }
    if(req.body.commisionPayStructure){
    shopBarbersModel.commisionPayStructure =  req.body.commisionPayStructure
    }
    if(req.body.rentPayStructure){
    shopBarbersModel.rentPayStructure =  req.body.rentPayStructure
    }
    // Auto Generate Password
    if(req.body.password){
        // Converting into Hash
        const hash = await bcrypt.hash(req.body.password, 10);
        shopBarbersModel.password   = hash
    }else{
        let autoGeneratedPassword = makeid(8);
        const hash = await bcrypt.hash(autoGeneratedPassword, 10);
        shopBarbersModel.password   = hash
    }
    
    // const customer = await stripe.customers.create({
    //     email:req.body.email.toLowerCase(),
    //     name: req.body.userName,

    // })
    // user.stripeCustomerId = customer.id

        await shopBarbersModel.save(async function (err, shopBarbersModel) {
            if (err) {
                if (err.name === 'MongoError' && err.code === 11000) {
                  // Duplicate username
                  return res.status(400).send({ succes: false, message: 'User already exist!' });
                }
          
                // Some other error
                return res.status(400).send({success: false, message: err});
              }
            //   Saving this user in admin main model so in every sense barber and admin will be connected with each other
              adminuser.businessAllBarbers.push(shopBarbersModel._id)
              adminuser.save();
             // Twillio Send Otp

            res.send({
                data: shopBarbersModel,
                success: true,
                message: "Signup Sucessfully & Code has been sent to the number!"
            });
        });        
    } catch (error) {
        console.log('errr', error)
        res.status(500).send({
            success: false, message:"Server Internal Error"
        });
    }

};

// Update Barber Profile data
exports.updateBarber = async function (req, res) {
    try {
        if (!req.body.barberId || !req.body.shopAdminAccountId) return res.status(400).send({success: false, message:"Invalid Request"});
    const user = await ShopBarbersModel.findOne({
        _id: req.body.barberId,
        shopAdminAccountId: req.body.shopAdminAccountId
    });
    if (!user) return res.status(400).send({success: false, message:"User Not Found. Please contact Flair Support"});
    
    if(req.body.firstName){
        user.firstName  = req.body.firstName        
    }
    if(req.body.lastName){
        user.lastName   = req.body.lastName     
    }
    if(req.body.userProfileLogo){
        user.userProfileLogo =  req.body.userProfileLogo 
    }
    if(req.body.email){
        const emailChecking = await ShopBarbersModel.findOne({
            email: req.body.email,
            shopAdminAccountId: req.body.shopAdminAccountId
        })
        if (emailChecking) return res.status(400).send({success: false, message:"Email already exist"}); 
        user.email = req.body.email
    }
    if(req.body.userCurrentPassword && req.body.userNewPassword){
        const passwordCompare = await bcrypt.compare(
            req.body.userCurrentPassword,
            user.password
        );
        if (!passwordCompare) return res.status(400).send({success: false, message:"Password Incorrect"})
        const hash = await bcrypt.hash(req.body.userNewPassword, 10);
        user.password   = hash
    }
    if(req.body.mobile){
        const userMobileChecking = await ShopBarbersModel.findOne({
            mobile: req.body.mobile,
            shopAdminAccountId: req.body.shopAdminAccountId
        })
        if (userMobileChecking) return res.status(400).send({success: false, message:"Mobile already exist"});
        user.mobile = req.body.mobile
    }
    if(req.body.isOnCommission){
        user.isOnCommission = req.body.isOnCommission
    }
    if(req.body.role){
        user.role = req.body.role
    }
    if(req.body.isOnRent){
        user.isOnRent = req.body.isOnRent
    } 
    if(req.body.commissionPayoutFrequency){
        user.commissionPayoutFrequency = req.body.commissionPayoutFrequency
    }
    if(req.body.rentCollectionFrequency){
        user.rentCollectionFrequency = req.body.rentCollectionFrequency
    }
    if(req.body.commisionPayStructure){
        user.commisionPayStructure = req.body.commisionPayStructure
    }
    if(req.body.rentPayStructure){
        user.rentPayStructure = req.body.rentPayStructure
    } 
    if(req.body.dob){
        user.dob = req.body.dob
    }
    if(req.body.gender){
        user.gender = req.body.gender
    }
    if(req.body.about){
        user.about = req.body.about
    }
    if(req.body.instagram){
        user.instagram = req.body.instagram
    }
    if(req.body.workingLocation){
        user.workingLocation.push(req.body.workingLocation)
    }
    if(req.body.barberPhotosGallery){
        user.barberPhotosGallery.push(req.body.barberPhotosGallery)
    } 
    if(req.body.appointmentRequest){
        user.appointmentRequest = req.body.appointmentRequest
    }
    if(req.body.noShowCharge){
        user.noShowCharge = req.body.noShowCharge
    }
    if(req.body.cancellationPolicy){
        user.cancellationPolicy = req.body.cancellationPolicy
    }
    if(req.body.cancellationWindowHour){
        user.cancellationWindowHour = req.body.cancellationWindowHour
    }
    // const customer = await stripe.customers.create({
    //     email:req.body.email.toLowerCase(),
    //     name: req.body.userName,

    // })
    // user.stripeCustomerId = customer.id
        await user.save(async function (err, user) {
            if (err) {
                if (err.name === 'MongoError' && err.code === 11000) {
                  // Duplicate username
                  return res.status(400).send({ succes: false, message: 'User already exist!' });
                }
          
                // Some other error
                return res.status(400).send({success: false, message: err});
              }
            

            res.send({
                data: user._id,
                success: true,
                message: "Updated!"
            });
        });        
    } catch (error) {
        console.log('err',error)
        res.status(500).send({
            success: false, message:"Server Internal Error"
        });
    }

};

// Add Barber Working Hour in each branch
exports.addBarberWorkingHour = async function (req, res) {
    try {
      if (!req.body.shopAdminAccountId || !Array.isArray(req.body.addWorkingHour))
        return res.status(400).send({ success: false, message: "Invalid Request" });
      if (req.user.userType !== "barber")
        return res.status(400).send({ success: false, message: "You do not have access" });
  
      const user = await ShopBarbersModel.findOne({
        _id: req.user._id,
        shopAdminAccountId: req.body.shopAdminAccountId,
      });
      if (!user)
        return res
          .status(400)
          .send({ success: false, message: "Barber Not Found. Please contact Flair Support" });
  
      const validationPromises = req.body.addWorkingHour.map(async (workingHour) => {
        const dayOfWeek = workingHour.dayOfWeek.toLowerCase();
        const startTime = workingHour.startTime;
        const endTime = workingHour.endTime;
        const shopBranchId = workingHour.shopBranch;
  
        const validationOfTime = await validateBarberWorkingHours(
          req.user._id,
          shopBranchId,
          dayOfWeek,
          startTime,
          endTime
        );
        // console.log("RESULT ============>", validationOfTime);
        if(validationOfTime.success ===false)return res.status(400).send({ success: false, message: validationOfTime.message });
  
        // Create the working hours object
        const workingHours = {
          shopBranch: shopBranchId,
          dayOfWeek: dayOfWeek,
          startTime: startTime,
          endTime: endTime,
        };
  
        // Push the working hours object to the array
        user.workingHours.push(workingHours);
      });
  
      // Wait for all the validation promises to resolve
      await Promise.all(validationPromises);
  
      // Save the user and send the response
      await user.save(async function (err, user) {
          if (err) {
              if (err.name === 'MongoError' && err.code === 11000) {
                // Duplicate username
                return res.status(400).send({ succes: false, message: 'User already exist!' });
              }
      
              // Some other error
              return res.status(400).send({success: false, message: err});
            }
      
          res.send({
              data: user.workingHours,
              success: true,
              message: "Added!"
          });
      });
    } catch (error) {
      console.log("err", error);
      res.status(500).send({
        success: false,
        message: "Server Internal Error",
      });
    }
  };

// Send OTP Barber phone Number in order to change mobile number
exports.sendOTPOnNumberForMobileNumberChange = async function (req, res) {
    try {
        if (!req.body.barberId || !req.body.shopAdminAccountId) return res.status(400).send({success: false, message:"Invalid Request"});
        const user = await ShopBarbersModel.findOne({
            _id: req.body.barberId,
            shopAdminAccountId: req.body.shopAdminAccountId
        });
        if(!user) return res.status(400).send({success: false, message:"Sorry Information was not correct"});

            // Mobile Verification
        user.mobileVerifyToken = Math.floor(1000 + Math.random() * 9000);
    
        const expiryTime = moment().add(1, 'minute'); // Set expiry time 1 minute from now
        user.mobileVerifyTokenExpires = expiryTime;

        await user.save(async function (err, user) {
            if (err) {
                if (err.name === 'MongoError' && err.code === 11000) {
                  // Duplicate username
                  return res.status(400).send({ succes: false, message: 'Some Data is Wrong!' });
                }
          
                // Some other error
                return res.status(400).send({success: false, message: err});
              }
    
            // Twillio Comes here
    
            res.send({
                success: true,
                message: "OTP Send"
            });
        });

    }catch (error) {
        res.status(500).send({
            success: false, message:"Server Internal Error"
        });
    }
}

// Verify Otp For Mobile Number Change
exports.verifyOtpForMobileNumberChange = async function (req, res) {
    try {
        if (!req.body.otp || !req.body.barberId || !req.body.shopAdminAccountId) return res.status(400).send({success: false, message:"Invalid Request"});
        const user = await ShopBarbersModel.findOne({
            _id: req.body.barberId,
            mobileVerifyToken: req.body.otp,
            shopAdminAccountId: req.body.shopAdminAccountId
        });
        if(!user)  return res.status(400).send({success: false, message:"Otp Incorrect"});

        // if (user.mobileVerifyTokenExpires < Date.now()) return res.status(400).send({success: false, message:"Otp Expired"});
                const currentTime = moment();
                const isExpired = currentTime.isAfter(user.mobileVerifyTokenExpires);
                if (isExpired) return res.status(400).send({success: false, message:"Otp Expired"});

        res.send({
            success: true,
            message: "OTP Correct!"
        });
    }catch (error) {
        res.status(500).send({
            success: false, message:"Server Internal Error"
        });
    }
}

// Add Each Barber Service
exports.addBarberServices = async function (req, res) {
    try {
    if (!req.body.shopAdminAccountId || !req.body.shopServiceId || !req.body.serviceTime || !req.body.staticPricing || !req.body.dynamicPricing || !req.body.mondayPrice || !req.body.tuesdayPrice || !req.body.wednesdayPrice || !req.body.thursdayPrice || !req.body.fridayPrice || !req.body.saturdayPrice || !req.body.sundayPrice) return res.status(400).send({success: false, message:"Invalid Request"});
    if(req.user.userType !== "barber") return res.status(400).send({success: false, message:"You do not have excess"});

    // Checking Barber Exist also for saving purpose
    const shopBarbersModel = await ShopBarbersModel.findOne({
        _id: req.user._id
	})
    if (!shopBarbersModel) return res.status(400).send({success: false, message:"Barber Not Found"});

    // Checking Shop Service
    const shopServicesModel = await ShopServicesModel.findOne({
        _id: req.body.shopServiceId
	})
    if (!shopServicesModel) return res.status(400).send({success: false, message:"Service Not Found"});
    let stringifyAdminAccountId = shopServicesModel.shopAdminAccountId.toString();
    if(stringifyAdminAccountId !== req.body.shopAdminAccountId) return res.status(400).send({success: false, message:"Sorry selected service is not available for this shop"});

    var barberChoosenServicesModel = new BarberChoosenServicesModel();
    barberChoosenServicesModel.shopAdminAccountId =  req.body.shopAdminAccountId
    barberChoosenServicesModel.barberAccountId =  req.user._id
    barberChoosenServicesModel.shopServiceId =  req.body.shopServiceId
    barberChoosenServicesModel.serviceTime =  req.body.serviceTime
    barberChoosenServicesModel.staticPricing =  req.body.staticPricing
    barberChoosenServicesModel.dynamicPricing =  req.body.dynamicPricing
    barberChoosenServicesModel.mondayPrice =  req.body.mondayPrice
    barberChoosenServicesModel.tuesdayPrice =  req.body.tuesdayPrice
    barberChoosenServicesModel.wednesdayPrice =  req.body.wednesdayPrice
    barberChoosenServicesModel.thursdayPrice =  req.body.thursdayPrice
    barberChoosenServicesModel.fridayPrice =  req.body.fridayPrice
    barberChoosenServicesModel.saturdayPrice =  req.body.saturdayPrice
    barberChoosenServicesModel.sundayPrice =  req.body.sundayPrice
    barberChoosenServicesModel.barberDescription =  req.body.barberDescription
    barberChoosenServicesModel.priceMayChange =  req.body.priceMayChange
    
        await barberChoosenServicesModel.save(async function (err, barberChoosenServicesModel) {
            if (err) {
                if (err.name === 'MongoError' && err.code === 11000) {
                  // Duplicate username
                  return res.status(400).send({ succes: false, message: 'Something Went Wrong. Contact Flair Support' });
                }
          
                // Some other error
                return res.status(400).send({success: false, message: err});
              }

            //   Saving id inside barber main schema & Also saving in shopservice schema
            shopBarbersModel.choosenServices.push(barberChoosenServicesModel._id)
            shopServicesModel.shopBarbersAttachWithThisService.push(req.user._id)
            await shopBarbersModel.save();
            await shopServicesModel.save();

            res.send({
                data: barberChoosenServicesModel,
                success: true,
                message: "Added Service"
            });
        });        
    } catch (error) {
        console.log('errr', error)
        res.status(500).send({
            success: false, message:"Server Internal Error"
        });
    }

};

// Update Single Barber Service
exports.updateBarberService = async function (req, res) {
    try {
        if (!req.body.shopAdminAccountId || !req.body.barberChoosenServiceId) return res.status(400).send({success: false, message:"Invalid Request"});
        if(req.user.userType !== "barber") return res.status(400).send({success: false, message:"You do not have excess"});
     console.log('data',req.user._id)
    const user = await BarberChoosenServicesModel.findOne({
        _id: req.body.barberChoosenServiceId,
        barberAccountId: req.user._id,
        shopAdminAccountId: req.body.shopAdminAccountId
    });
    if (!user) return res.status(400).send({success: false, message:"Service Not Found of this barber. Some info is incorrect"});
    
    if(req.body.barberDescription){
        user.barberDescription  = req.body.barberDescription        
    }
    if(req.body.serviceTime){
        user.serviceTime   = req.body.serviceTime     
    }
    if(req.body.staticPricing){
        user.staticPricing =  req.body.staticPricing 
    }
    if(req.body.dynamicPricing){
        user.dynamicPricing = req.body.dynamicPricing
    }
    if(req.body.priceMayChange){
        user.priceMayChange = req.body.priceMayChange
    }
    if(req.body.mondayPrice){
        user.mondayPrice = req.body.mondayPrice
    }
    if(req.body.tuesdayPrice){
        user.tuesdayPrice = req.body.tuesdayPrice
    }
    if(req.body.wednesdayPrice){
        user.wednesdayPrice = req.body.wednesdayPrice
    }
    if(req.body.thursdayPrice){
        user.thursdayPrice = req.body.thursdayPrice
    }
    if(req.body.fridayPrice){
        user.fridayPrice = req.body.fridayPrice
    }
    if(req.body.saturdayPrice){
        user.saturdayPrice = req.body.saturdayPrice
    }
    if(req.body.sundayPrice){
        user.sundayPrice = req.body.sundayPrice
    }
    // const customer = await stripe.customers.create({
    //     email:req.body.email.toLowerCase(),
    //     name: req.body.userName,

    // })
    // user.stripeCustomerId = customer.id
        await user.save(async function (err, user) {
            if (err) {
                if (err.name === 'MongoError' && err.code === 11000) {
                  // Duplicate username
                  return res.status(400).send({ succes: false, message: 'User already exist!' });
                }
          
                // Some other error
                return res.status(400).send({success: false, message: err});
              }
            

            res.send({
                data: user,
                success: true,
                message: "Updated!"
            });
        });        
    } catch (error) {
        console.log('err',error)
        res.status(500).send({
            success: false, message:"Server Internal Error"
        });
    }

};

// Get All Ctegories of Shop List
exports.getAllCategoriesOfShopList = async (req, res) => {
    try{
        if (!req.body.shopAdminAccountId) return res.status(400).send({success: false, message:"Invalid Request"});
        if(req.user.userType !== "barber") return res.status(400).send({success: false, message:"You do not have excess"});
       
        const shopServicesCategoryModel = await ShopServicesCategoryModel.find({
            shopAdminAccountId: req.body.shopAdminAccountId
        }).populate("shopServicesAttachWithThisCategory")
        if (!shopServicesCategoryModel.length) return res.status(400).send({success: false, message:"Categories and services Not Found"}); 
        

            res.send({
                data: shopServicesCategoryModel,
                success: true,
                message: "Categories!"
            });
    }catch (error) {
        console.log('err',error)
        res.status(500).send({
            success: false,error, message:"Server Internal Error"
        });
    }
};

// Save New Barber Card   ----> Testing
exports.saveCard = async (req, res) => {
    try{
        if (!req.body.cardToken) return res.status(400).send({success: false, message:"Invalid Request"});
        if(req.user.userType !== "barber") return res.status(400).send({success: false, message:"You do not have excess"});
        
        const user = await ShopBarbersModel.findOne({
            _id: req.user._id,
            shopAdminAccountId: req.user.shopAdminAccountId
        });
        if (!user) return res.status(400).send({success: false, message:"User Not Found. Please contact Flair Support"});

        const customerId = req.user.stripeCustomerId;
        const cardToken = req.body.cardToken;
        const cardId = await saveCard(customerId, cardToken);


        user.stripeSavedCardIds.push(cardId);

        await user.save(async function (err, user) {
            if (err) {
                if (err.name === 'MongoError' && err.code === 11000) {
                  // Duplicate username
                  return res.status(400).send({ succes: false, message: 'User already exist!' });
                }
          
                // Some other error
                return res.status(400).send({success: false, message: "Something Went Wrong"});
              }
            

            res.send({
                data: user._id,
                success: true,
                message: "Updated!"
            });
        });  
        
    }catch (error) {
        console.log("err",error)
        res.status(500).send({
            success: false,error, message:"Server Internal Error"
        });
    }
};


// Barber Client Request List
exports.barberClientRequest = async (req, res) => {
    try {
        if(req.user.userType !== "barber") return res.status(400).send({success: false, message:"You do not have excess"});
      const barberId = req.user._id; // Get barberId from frontend request
  
      // Get current date and time
      const currentDateTime = new Date();
  
      const bookings = await BookingModel.find({
        'selectedBarber': barberId,
        'isConfirmedByBarber': false,
        $or: [
          { 'bookingDate': { $gt: currentDateTime } }, // Filter for future bookings
          {
            'bookingDate': { $eq: currentDateTime }, // Include bookings with the same date as current date
            'bookingTime.startTime': { $gte: currentDateTime.getHours() + ':' + currentDateTime.getMinutes() } // Include bookings with start time greater than or equal to current time
          }
        ]
      })
        .sort({ 'bookingDate': 1, 'bookingTime.startTime': 1 }) // Sort by bookingDate and bookingTime.startTime in ascending order
        .populate('customer') // Populate the customer field
        .exec();
        if (!bookings.length) return res.status(400).send({success: false, message:"There is no client request"});
  
        res.send({
            data: bookings,
            success: true,
            message: "Client requests of barber!"
        });
    } catch (error) {
        res.status(500).send({
            success: false,error, message:"Server Internal Error"
        });
    }
  }

// Approve Or decline Client Request of barber
exports.barberClientRequestApproveOrDecline = async (req, res) => {
    try {
        if (!req.body.bookingId || !req.body.action) return res.status(400).send({success: false, message:"Invalid Request"});
        if(req.user.userType !== "barber") return res.status(400).send({success: false, message:"You do not have excess"});

      const bookingId = req.body.bookingId;
      const action = req.body.action; // 'approve' or 'decline'
  
      let updateFields = {};
  
      if (action === 'approve') {
        updateFields = {
          isConfirmedByBarber: true,
          confirmationDate: new Date(),
          bookingStatus: 'reserved'
        };
      } else if (action === 'decline') {
        updateFields = {
          isConfirmedByBarber: false,
          bookingStatus: 'cancelled',
          isPermanentalyDeclinedByBarber: true
        };
      } else {
        return res.status(400).send({success: false, message:"Invalid Data"});
      }
  
      const updatedBooking = await BookingModel.findByIdAndUpdate(
        bookingId,
        updateFields,
        { new: true }
      );
  
      if (!updatedBooking) {
        return res.status(400).send({success: false, message:"Booking Not Found"});
      }
  
      res.status(200).json(updatedBooking);
      res.send({
        data: updatedBooking,
        success: true,
        message: "Updated"
    });
    } catch (error) {
        res.status(500).send({
            success: false,error, message:"Server Internal Error"
        });
    }
}

// Get Barber Upcoming Booking
exports.getUpcomingBookingsForBarber = async (req, res) => {
    try {
      if (!req.body.page) return res.status(400).send({ success: false, message: "Invalid Request" });
      if (req.user.userType !== "barber") return res.status(400).send({ success: false, message: "You do not have access" });
  
      const pageSize = 10; // Set the number of bookings per page
      const page = req.body.page || 1; // Get the current page from the query parameter
  
      const currentDate = moment().toDate();
      const upcomingBookings = await BookingModel.find({
        selectedBarber: req.user._id, // Update the condition to match the selectedBarber field
        isConfirmedByBarber: true,
        $or: [
          { bookingDate: { $gt: currentDate } },
          {
            bookingDate: currentDate,
            'bookingTime.startTime': { $gte: moment().format('HH:mm') },
          },
        ],
        bookingStatus: { $in: ['pending', 'reserved', 'inprogress'] },
      }).populate("customer")
      .populate({
        path: 'selectedBarberServices.service',
        model: 'barberschoosenservice',
        populate: {
          path: 'shopServiceId',
          model: 'shopservices',
        },
      })
        .sort({ 'bookingTime.startTime': 1 })
        .skip((page - 1) * pageSize)
        .limit(pageSize);
  
      if (!upcomingBookings.length) return res.status(400).send({ success: false, message: "There are no upcoming bookings" });
  
      res.send({
        data: upcomingBookings,
        success: true,
        message: "Upcoming Bookings"
      });
    } catch (error) {
      res.status(500).send({
        success: false,
        error,
        message: "Server Internal Error"
      });
    }
  };

//   Get Past Booking For Barber
  exports.getPastBookingsForBarber = async (req, res) => {
    try {
        if (!req.body.page) return res.status(400).send({success: false, message:"Invalid Request"});
        if(req.user.userType !== "barber") return res.status(400).send({success: false, message:"You do not have excess"});
        
        const pageSize = 10; // Set the number of bookings per page
        const page = req.body.page || 1; // Get the current page from the query parameter

      const currentDate = moment().toDate();

      const totalBookings = await BookingModel.countDocuments({
        selectedBarber: req.user._id,
        bookingDate: { $lt: currentDate },
        bookingStatus: { $in: ['completed', 'cancelled'] },
      });
  
      const pastBookings = await BookingModel.find({
        selectedBarber: req.user._id,
        bookingDate: { $lte: currentDate },
        bookingStatus: { $in: ['completed', 'cancelled'] }
      }).populate("customer")
      .populate({
        path: 'selectedBarberServices.service',
        model: 'barberschoosenservice',
        populate: {
          path: 'shopServiceId',
          model: 'shopservices',
        },
      })
        .sort({ bookingDate: -1, 'bookingTime.startTime': -1 }).skip((page - 1) * pageSize)
        .limit(pageSize); // Sort by booking date and start time in descending order

        if (!pastBookings.length) return res.status(400).send({success: false, message:"There is no past bookings"});
  
      res.send({
        data: pastBookings,
        currentPage: page,
        totalPages: Math.ceil(totalBookings / pageSize),
        success: true,
        message: 'Past Bookings'
      });
    } catch (error) {
      res.status(500).send({
        success: false,
        error,
        message: 'Server Internal Error'
      });
    }
  };

// Get Single Booking Details
exports.getSingleBookingDetail = async (req, res) => {
    try{
        if (!req.body.bookingId) return res.status(400).send({success: false, message:"Invalid Request"});
        if(req.user.userType !== "barber") return res.status(400).send({success: false, message:"You do not have excess"});
       
        const bookingModel = await BookingModel.findOne({
            shopAdminAccountId: req.user.shopAdminAccountId,
            _id: req.body.bookingId,
            selectedBarber: req.user._id
        }).populate("customer").populate({
          path: 'selectedBarberServices.service',
          model: 'barberschoosenservice',
          populate: {
            path: 'shopServiceId',
            model: 'shopservices',
          },
        })
        if (!bookingModel) return res.status(400).send({success: false, message:"Sorry booking not found"}); 
        

            res.send({
                data: bookingModel,
                success: true,
                message: "Booking Detail!"
            });
    }catch (error) {
        console.log('err',error)
        res.status(500).send({
            success: false,error, message:"Server Internal Error"
        });
    }
};

// Image URL Save
exports.saveBarberPhotoGallery = async (req, res) => {
    try {
        if (!req.body.barberId || !req.body.imageUrl) return res.status(400).send({success: false, message:"Invalid Request"});
        if(req.user.userType !== "barber") return res.status(400).send({success: false, message:"You do not have excess"});
      // Get the barber ID from the request body
      const { barberId } = req.body;
  
      // Get the image URL from the request body
      const { imageUrl } = req.body;
  
      // Find the barber by ID in the database
      const barber = await ShopBarbersModel.findById({ _id: barberId});
  
      // If the barber is not found, return an error response
      if (!barber) {
        return res.status(400).json({
          success: false,
          message: 'Barber not found',
        });
      }
  
      // Create a new image object with the provided URL
      const imageObject = {
        _id: new mongoose.Types.ObjectId(),
        imageUrl: imageUrl,
      };
  
      // Add the image object to the barber's photo gallery
      barber.barberPhotosGallery.push(imageObject);
  
      // Save the updated barber data in the database
      await barber.save(async function (err, user) {
        if (err) {
            if (err.name === 'MongoError' && err.code === 11000) {
              // Duplicate username
              return res.status(400).send({ succes: false, message: 'User already exist!' });
            }
      
            // Some other error
            return res.status(400).send({success: false, message: "Something Went Wrong"});
          }   
          
          // Return a success response
          return res.status(200).json({
            data: barber,
            success: true,
            message: 'Image uploaded successfully',
          });
    });  
  
    } catch (error) {
      // Return an error response if any error occurs
      return res.status(500).json({
        success: false,
        error: error.message,
        message: 'Image upload failed',
      });
    }
}  

// Delete Single Specific Image URL
exports.deleteBarberSinglePhotoUrl = async (req, res) => {
    try {
        if (!req.body.barberId || !req.body.imageId) return res.status(400).send({success: false, message:"Invalid Request"});
        if(req.user.userType !== "barber") return res.status(400).send({success: false, message:"You do not have excess"});
      // Get the barber ID and image ID from the request body
      const { barberId, imageId } = req.body;
  
      // Find the barber by ID in the database
      const barber = await ShopBarbersModel.findById({_id: barberId});
  
      // If the barber is not found, return an error response
      if (!barber) {
        return res.status(400).json({
          success: false,
          message: 'Barber not found',
        });
      }
  
      // Find the index of the image with the provided ID in the barber's photo gallery
      const imageIndex = barber.barberPhotosGallery.findIndex(
        (image) => image._id.toString() === imageId
      );
  
      // If the image is not found, return an error response
      if (imageIndex === -1) {
        return res.status(400).json({
          success: false,
          message: 'Image not found',
        });
      }
  
      // Remove the image from the barber's photo gallery array
      barber.barberPhotosGallery.splice(imageIndex, 1);
  
      // Save the updated barber data in the database
      await barber.save(async function (err, user) {
        if (err) {
            if (err.name === 'MongoError' && err.code === 11000) {
              // Duplicate username
              return res.status(400).send({ succes: false, message: 'User already exist!' });
            }
      
            // Some other error
            return res.status(400).send({success: false, message: "Something Went Wrong"});
          }   
          
          // Return a success response
          return res.status(200).json({
            data: barber,
            success: true,
            message: 'Image deleted successfully',
          });
    }); 

    } catch (error) {
      // Return an error response if any error occurs
      return res.status(500).json({
        success: false,
        error: error.message,
        message: 'Failed to delete image',
      });
    }
}

// Add Barber Block Time
exports.addBarberBlockTime = async (req, res) => {
  try {
    if (!req.body.startTime || !req.body.endTime || !req.body.description) return res.status(400).send({success: false, message:"Invalid Request"});
    if(req.user.userType !== "barber") return res.status(400).send({success: false, message:"You do not have excess"});
    
    const { startTime, endTime, description } = req.body;
    const barberId = req.user._id;
    // Check this barber in DB
    const barber = await ShopBarbersModel.findOne({_id: barberId});
  
      // If the barber is not found, return an error response
      if (!barber) {
        return res.status(400).json({
          success: false,
          message: 'Barber not found',
        });
      }
    
    // Check that it should not be any past day
    const currentDate = moment().startOf('day'); // Get the current date without the time component

    const providedDate = moment(startTime).startOf('day'); // Get the provided date without the time component

    if (providedDate.isBefore(currentDate)) return res.status(400).send({success: false, message:"Error: The provided date is in the past."});


    // Check for conflicting bookings
const startDate = startTime.split('T')[0];
  const endDate = endTime.split('T')[0];
  const startTimeValue = startTime.split('T')[1];
  const endTimeValue = endTime.split('T')[1];

  const startDateTime = new Date(startDate);
  const endDateTime = new Date(endDate);

  startDateTime.setHours(startTimeValue.split(':')[0], startTimeValue.split(':')[1], 0, 0);
  endDateTime.setHours(endTimeValue.split(':')[0], endTimeValue.split(':')[1], 0, 0);

  const existingBooking = await BookingModel.findOne({
    selectedBarber: barberId,
    shopAdminAccountId: req.user.shopAdminAccountId,
    bookingStatus: { $in: ['reserved', 'inprogress', 'pending', ] },
    bookingDate: {
      $gte: startDateTime,
      $lte: endDateTime,
    },
    $or: [
      {
        $and: [
          { 'bookingTime.startTime': { $lte: startTimeValue }, 'bookingTime.endTime': { $gte: startTimeValue } }
        ]
      },
      {
        $and: [
          { 'bookingTime.startTime': { $lte: endTimeValue }, 'bookingTime.endTime': { $gte: endTimeValue } }
        ]
      },
      {
        $and: [
          { 'bookingTime.startTime': { $gte: startTimeValue, $lte: endTimeValue } }
        ]
      }
    ]
  });

  if (existingBooking) {
    return res.status(400).json({ error: 'The barber already has a booking at the selected time.' });
  }
  console.log("startTime", startTime);
  console.log("End Time", endTime);

  // Converting into UTC Time
  const startUtcTime = moment.utc(startTime).toDate();
  const endUtcTime = moment.utc(endTime).toDate();

    // Check for duplicate block times
    const duplicateBlockTime = await BlockTime.findOne({
      barberId,
      startTime: startUtcTime,
      endTime: endUtcTime
    });

    if (duplicateBlockTime) {
      return res.status(400).json({ error: 'A block time already exists for the selected time range.' });
    }

    // Create new block time
    const newBlockTime = new BlockTime({
      shopAdminAccountId: req.user.shopAdminAccountId,
      barberId,
      startTime: startUtcTime,
      endTime: endUtcTime,
      description,
    });

    // Save the block time to the database
    await newBlockTime.save(async function (err, data) {
      if (err) {
          if (err.name === 'MongoError' && err.code === 11000) {
            // Duplicate username
            return res.status(400).send({ succes: false, message: 'User already exist!' });
          }
    
          // Some other error
          console.log("err", err)
          return res.status(400).send({success: false, message: "Something Went Wrong"});
        }   

        barber.barberBlockTime.push(data._id);
        await barber.save();
        
        // Return a success response
        return res.status(200).json({
          data: data,
          success: true,
          message: 'Block time added successfully.',
        });

      })
  } catch (error) {
    console.error(error);
    res.status(500).json({ error: 'An error occurred while adding block time.' });
  }
}

// Get Specific Barber Block Time
exports.getFutureBarberBlockTime = async (req, res) => {
  try {
    if (!req.body.startTime || !req.body.endTime || !req.body.page || !req.body.pageSize) return res.status(400).json({success: false, message:"Invalid Request"});
    if(req.user.userType !== "barber") return res.status(400).json({success: false, message:"You do not have excess"});
    const barberId = req.user._id
    const currentPage = parseInt(req.body.page) || 1;
    const pageSize = parseInt(req.body.pageSize) || 10;
    const skip = (currentPage - 1) * pageSize;

// Converting into UTC Time
  // const startTime = moment.utc(startTime).toDate();
  // const endTime = moment.utc(endTime).toDate();

    // const ctDate =  new Date();
    const startUtcTime = moment.utc().toDate();
const endUtcTime = moment.utc().add(100, 'years').toDate();

const query = {
  barberId,
  startTime: { $gte: startUtcTime },
};

const totalBlocks = await BlockTime.countDocuments(query);
const totalPages = Math.ceil(totalBlocks / pageSize);

const blocks = await BlockTime.find(query)
  .sort({ startTime: 'asc' })
  .skip(skip)
  .limit(pageSize);

      if(!blocks.length) return res.status(400).json({success: false, message:"There is no block time"});

    res.json({
      currentPage,
      totalPages,
      pageSize,
      totalBlocks,
      blocks,
    });
    return res.status(200).json({
      data: blocks,
      currentPage,
      totalPages,
      pageSize,
      totalBlocks,
      success: true,
      message: 'Block time.',
    });
  } catch (error) {
    console.log("eee",error)
    res.status(500).json({ error: 'An error occurred while retrieving barber block time.' });
  }
}

// Delete Single Block Of Barber
exports.deleteBlockById = async (req, res) => {
  try {
    if (!req.body.blockId) return res.status(400).json({success: false, message:"Invalid Request"});
    if(req.user.userType !== "barber") return res.status(400).json({success: false, message:"You do not have excess"});
    const { blockId } = req.body;

    // Validate blockId format
    if (!mongoose.isValidObjectId(blockId)) {
      return res.status(400).json({ success: false, message: 'Invalid block ID' });
    }

    // Find and delete the block
    const deletedBlock = await BlockTime.findByIdAndDelete({_id: blockId, barberId: req.user._id});

    // Check if the block exists
    if (!deletedBlock) {
      return res.status(400).json({ success: false, message: 'Block not found' });
    }

    return res.status(200).json({ success: true, message: 'Block deleted successfully' });
  } catch (error) {
    console.log(error);
    return res.status(500).json({ success: false, message: 'An error occurred while deleting the block' });
  }
};

// Get specific range of date of Appointments
exports.getAppointementbasedOnDateRange = async (req, res) => {
  try {
    const { startDate, endDate, page } = req.body;

    if (!startDate || !endDate || !page) {
      return res.status(400).send({ success: false, message: "Invalid Request" });
    }
    if(req.user.userType !== "barber") return res.status(400).json({success: false, message:"You do not have excess"});

    const startOfDay = moment(startDate).startOf('day').toDate();
    const endOfDay = moment(endDate).endOf('day').toDate();

    const pageSize = 10; // Set the number of bookings per page
    const currentPage = parseInt(page) || 1; // Get the current page from the request

    const totalBookings = await BookingModel.countDocuments({
      selectedBarber: req.user._id,
      isConfirmedByBarber: true,
      bookingDate: { $gte: startOfDay, $lte: endOfDay },
      bookingStatus: { $in: ['pending', 'reserved', 'inprogress'] },
    });

    const totalPages = Math.ceil(totalBookings / pageSize);
    const skip = (currentPage - 1) * pageSize;

    const upcomingBookings = await BookingModel.find({
      selectedBarber: req.user._id,
      isConfirmedByBarber: true,
      bookingDate: { $gte: startOfDay, $lte: endOfDay },
      bookingStatus: { $in: ['pending', 'reserved', 'inprogress'] },
    })
      .populate("customer")
      .populate({
        path: 'selectedBarberServices.service',
        model: 'barberschoosenservice',
        populate: {
          path: 'shopServiceId',
          model: 'shopservices',
        },
      })
      .sort({ 'bookingTime.startTime': 1 })
      .skip(skip)
      .limit(pageSize);

    if (!upcomingBookings.length) {
      return res.status(400).send({ success: false, message: "There are no upcoming bookings within the specified range" });
    }

    res.send({
      currentPage,
      totalPages,
      pageSize,
      totalBookings,
      data: upcomingBookings,
      success: true,
      message: "Upcoming Bookings"
    });
  } catch (error) {
    res.status(500).send({
      success: false,
      error,
      message: "Server Internal Error"
    });
  }
};

// Get Today Appointments
exports.getTodayBarberBookings = async (req, res) => {
  try {
    if (!req.body.page) return res.status(400).json({success: false, message:"Invalid Request"});
    if (req.user.userType !== 'barber') {
      return res.status(400).send({ success: false, message: 'You do not have access' });
    }

    const pageSize = req.body.pageSize || 10; // Set the number of bookings per page
    const page = req.body.page || 1; // Get the current page from the request body

    const currentDate = moment().startOf('day'); // Get the current date without the time

    const query = {
      selectedBarber: req.user._id,
      bookingDate: currentDate,
      bookingStatus: { $in: ['pending', 'reserved', 'inprogress'] },
      isConfirmedByBarber: true,
    };

    const totalBookings = await BookingModel.countDocuments(query);
    const totalPages = Math.ceil(totalBookings / pageSize);

    const todayBookings = await BookingModel.find(query)
      .populate('customer')
      .populate({
        path: 'selectedBarberServices.service',
        model: 'barberschoosenservice',
        populate: {
          path: 'shopServiceId',
          model: 'shopservices',
        },
      })
      .sort({ 'bookingTime.startTime': 1 })
      .skip((page - 1) * pageSize)
      .limit(pageSize);

    if (!todayBookings.length) {
      return res.status(400).send({ success: false, message: 'There are no bookings for today' });
    }

    res.send({
      data: todayBookings,
      currentPage: page,
      totalPages,
      pageSize,
      totalBookings,
      success: true,
      message: 'Today\'s Bookings',
    });
  } catch (error) {
    res.status(500).send({
      success: false,
      error,
      message: 'Server Internal Error',
    });
  }
};

// GET Barber Clients who previous books any booking with barber
exports.getCustomersOfBarber = async (req, res) => {
  try {
    if (!req.body.page) return res.status(400).json({success: false, message:"Invalid Request"});
    if (req.user.userType !== 'barber') {
      return res.status(400).send({ success: false, message: 'You do not have access' });
    }

    const barberId = req.user._id;
    const page = req.body.page || 1;
    const pageSize = 10;
    const skip = (page - 1) * pageSize;

    const bookings = await BookingModel.find({ selectedBarber: barberId })
      .sort({ bookingDate: -1, 'bookingTime.startTime': -1 })
      .populate('customer')
      .exec();

    const filteredBookings = bookings.filter((booking) => {
      const { bookingStatus } = booking;
      return ['completed', 'reserved', 'pending'].includes(bookingStatus);
    });

    const customerIds = filteredBookings.map((booking) => booking.customer._id);
    const uniqueCustomerIds = [...new Set(customerIds)];

    const customers = await ShopCustomersModel.find({ _id: { $in: uniqueCustomerIds } })
      .sort({ updatedAt: -1 })
      .skip(skip)
      .limit(pageSize)
      .exec();

    if (!customers.length) {
      return res.status(400).send({ success: false, message: 'No customers found' });
    }

    res.send({
      data: customers,
      success: true,
      message: 'Customers',
      currentPage: page,
      totalPages: Math.ceil(customers.length / pageSize),
      pageSize,
      totalCustomers: customers.length,
    });

  } catch (error) {
    console.log('ERR',error)
    res.status(500).send({
      success: false,
      error,
      message: 'Server Internal Error',
    });
  }
};

// Get Single Customer All Bookings with Barber
exports.getAllAppointmentsOfSingleCustomer = async (req, res) => {
  try {
    if (!req.body.customerId || !req.body.page) return res.status(400).json({success: false, message:"Invalid Request"});
    if (req.user.userType !== 'barber') {
      return res.status(400).send({ success: false, message: 'You do not have access' });
    }

    const barberId = req.user._id;
    const customerId = req.body.customerId;
    const page = req.body.page || 1;
    const pageSize = 10;
    const skip = (page - 1) * pageSize;

    const appointments = await BookingModel.find({
      customer: customerId,
      selectedBarber: barberId,
      bookingStatus: { $in: ['completed', 'cancelled'] },
    })
      .sort({ bookingDate: -1 }) // Sort appointments by bookingDate in descending order
      .skip((page - 1) * pageSize)
      .limit(pageSize)
      .populate("customer")
      .populate({
        path: "selectedBarberServices.service",
        model: "barberschoosenservice",
        populate: {
          path: "shopServiceId",
          model: "shopservices",
        },
      });

    if (!appointments.length) {
      return res.status(404).send({ success: false, message: "No appointments found" });
    }

    res.send({
      data: appointments,
      success: true,
      message: 'Appointments',
      currentPage: page,
      totalPages: Math.ceil(appointments.length / pageSize),
      pageSize,
      totalAppointments: appointments.length,
    });
  } catch (error) {
    res.status(500).send({
      success: false,
      error,
      message: 'Server Internal Error',
    });
  }
};

// Get Client Details
exports.getSingleClientDetails = async (req, res) => {
  try {
    
    if (!req.body.customerId) {
      return res.status(400).json({ success: false, message: "Invalid Request" });
    }
    if (req.user.userType !== 'barber') {
      return res.status(400).send({ success: false, message: 'You do not have access' });
    }

    const customerId = req.body.customerId;
    const barberId = req.user._id;

    const customer = await ShopCustomersModel.findById(customerId);

    if (!customer) {
      return res.status(400).send({ success: false, message: 'Customer not found' });
    }

    const bookings = await BookingModel.find({ selectedBarber: barberId, customer: customerId, bookingStatus: 'completed' })
      .sort({ bookingDate: -1, 'bookingTime.startTime': -1 })
      .populate('customer')
      .exec();

      const totalAppointments = bookings.length;
      const totalSpend = bookings.reduce((sum, booking) => sum + booking.totalPrice, 0);
      const averageSpend = totalSpend / totalAppointments;
  
      const firstBookingDate = bookings[totalAppointments - 1].bookingDate;
      const lastBookingDate = bookings[0].bookingDate;
      const weeksDiff = Math.ceil((lastBookingDate - firstBookingDate) / (7 * 24 * 60 * 60 * 1000));
      const averageAppointmentsPerWeek = totalAppointments / weeksDiff;

    res.send({
      success: true,
      customer,
      totalAppointments,
      averageSpend,
      averageAppointmentsPerWeek,
    });


  } catch (error) {
    console.log('ERR',error)
    res.status(500).send({
      success: false,
      error,
      message: 'Server Internal Error',
    });
  }
};

// Barber Side Checkout
exports.barberFinalBookingCheckout = async (req, res) => {
  try {
    
    if (!req.body.isThisCombinationOfPayment || !req.body.bookingId || !req.body.paymentMethodType) return res.status(400).json({ success: false, message: "Invalid Request" });
    if (req.user.userType !== 'barber') return res.status(400).send({ success: false, message: 'You do not have access' });
     
    if (req.body.isThisCombinationOfPayment === true) {
      return res.status(400).json({ success: false, message: "Invalid Request" });
    }

    // Validate payment methods
    const validPaymentMethods = ['stripe', 'cash', 'pos', 'other'];
    const selectedPaymentMethods = paymentMethodType.filter((method, index, self) => {
      if (!method.method || !validPaymentMethods.includes(method.method)) {
        return res.status(400).json({ success: false, message: `Invalid payment method: ${method.method}` });
      }
      if (self.findIndex((m) => m.method === method.method) !== index) {
        return res.status(400).json({ success: false, message: `Duplicate payment method found: ${method.method}` });
      }
      if (method.method === 'other' && !req.body.otherPaymentMethodname) {
        return res.status(400).json({ success: false, message: `Other payment method requires 'otherPaymentMethodname'.` });
      }
      return true;
    });

    if (selectedPaymentMethods.length === 0) {
      return res.status(400).send({ success: false, message: 'Invalid payment methods' });
    }

     // Retrieve the booking from the database
     const booking = await BookingModel.findOne({ _id: req.body.bookingId });

     // Check if the booking exists
     if (!booking) {
       return res.status(404).send({ success: false, message: 'Booking not found' });
     }


     // Calculate total amount due
    // const totalAmountDue = calculateTotalAmountDue(booking);

    // Handle points payment
    if (selectedPaymentMethods.includes('points')) {
      // Validate points payment
      // const isValidPointsPayment = validatePointsPayment(booking, totalAmountDue);

      // if (!isValidPointsPayment) {
      //   return res.status(400).send({ error: 'Invalid points payment' });
      // }

      // Process points payment
      // processPointsPayment(booking, totalAmountDue);

      // Update booking status and payment status
      booking.bookingStatus = 'completed';
      booking.paymentStatus = 'completed';
    } else {
      // Handle other payment methods
      const paymentTypeCount = selectedPaymentMethods.length;

      if (paymentTypeCount === 1) {
        // Single payment method selected
        const paymentMethod = selectedPaymentMethods[0];

        // Process single payment method
        // processSinglePayment(booking, paymentMethod, totalAmountDue);

        // Update booking status and payment status
        booking.bookingStatus = 'completed';
        booking.paymentStatus = 'completed';
      } else if (paymentTypeCount === 2) {
        // Two payment methods selected
        const paymentMethod1 = selectedPaymentMethods[0].method;
        const paymentMethod2 = selectedPaymentMethods[1].method;

        // Process two payment methods
        // Check if "cash" is present in either payment method
        if (paymentMethod1 === 'cash' || paymentMethod2 === 'cash') {
          console.log('Cash method mentioned');
          const matchingPaymentMethod = paymentMethod1 === 'cash' ? paymentMethod1 : paymentMethod2;
          const amount = matchingPaymentMethod === paymentMethod1 ? selectedPaymentMethods[0].amount : selectedPaymentMethods[1].amount;
          
          const paymentCashObj = {
            method: 'cash',
            amount,
            paid: true
          };
          booking.paymentMethodType.push(paymentCashObj);
        }

        // Check if "stripe" is present in either payment method
        if (paymentMethod1 === 'stripe' || paymentMethod2 === 'stripe') {
          console.log('Stripe method mentioned');
          const matchingPaymentMethod = paymentMethod1 === 'stripe' ? paymentMethod1 : paymentMethod2;
          const amount = matchingPaymentMethod === paymentMethod1 ? selectedPaymentMethods[0].amount : selectedPaymentMethods[1].amount;

          // Convert amount to cents
          const amountInCents = amount * 100;

          // Stripe Process
          chargeCustomerCardBarber(req.user.stripeCustomerId, amountInCents, req.body.paymentMethodToken, booking.savedStripeDebitOrCreditCardId);

          const paymentStripeObj = {
            method: 'stripe',
            amount,
            paid: true
          };
          booking.paymentMethodType.push(paymentStripeObj);
        }

        // Check if "pos" is present in either payment method
        if (paymentMethod1 === 'pos' || paymentMethod2 === 'pos') {
          console.log('POS method mentioned');
          const matchingPaymentMethod = paymentMethod1 === 'pos' ? paymentMethod1 : paymentMethod2;
          const amount = matchingPaymentMethod === paymentMethod1 ? selectedPaymentMethods[0].amount : selectedPaymentMethods[1].amount;

          // paymentToken will be provided by the ipad app
          const capturedPayment = await capturePaymentStripePOS(paymentToken, amount, currency);
        }

        // Check if "other" is present in either payment method
        if (paymentMethod1 === 'other' || paymentMethod2 === 'other') {
          console.log('Other method mentioned');
          const matchingPaymentMethod = paymentMethod1 === 'other' ? paymentMethod1 : paymentMethod2;
          const amount = matchingPaymentMethod === paymentMethod1 ? selectedPaymentMethods[0].amount : selectedPaymentMethods[1].amount;

          let paymentotherObj = {
            method: 'other',
            amount,
            paid: true
          }
          booking.paymentMethodType.push(paymentotherObj)
          booking.otherPaymentMethodname = req.body.otherPaymentMethodname
        }
        
        // Calculate subtotal amount based on selectedBarberServices with price and quantity
        const subtotal = booking.selectedBarberServices.reduce((total, service) => {
          const { price, quantity } = service.service;
          return total + (price * quantity);
        }, 0);

        // Add statesTaxesAndFees to the subtotal
        const totalAmountBeforeDiscount = subtotal + booking.statesTaxesAndFees;

        // Subtract totalDiscount percentage from the total amount
        const totalAmountAfterDiscount = totalAmountBeforeDiscount - (totalAmountBeforeDiscount * booking.totalDiscount / 100);

        // Check if all payment methods have paid as true
        const isAmountsMatchTotal = selectedPaymentMethods.every(method => method.amount === totalAmountAfterDiscount);
        const isFullAmountPaid = isAmountsMatchTotal && booking.paymentMethodType.every(method => method.paid);

        if (isFullAmountPaid) return res.status(400).send({ success: false, message: 'Full Amount not paid, There is one mthod not working' });


          console.log('Full amount paid');
          // Update booking status and payment status
          booking.bookingStatus = 'completed';
          booking.paymentStatus = 'completed';
          booking.checkoutDate = moment().utc();


      } else {
        // Invalid number of payment methods selected
        return res.status(400).send({ success: false, message: 'Invalid number of payment methods selected' });
      }
    }

    // Save the updated booking
    await booking.save();
    res.send({ message: 'Booking successfully checked out' });
 

  } catch (error) {
    console.log('ERR',error)
    res.status(500).send({
      success: false,
      error,
      message: 'Server Internal Error',
    });
  }
};